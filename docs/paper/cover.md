# 覆盖问题

## :gem:【2020】无线传感器网络中目标覆盖问题的传感器部署方法

> 摘要：传感器部署是无线传感器网络（WSNs）中的一个基本问题。对覆盖问题的研究主要集中在部署传感器来覆盖确定的区域或一组确定的点（目标）。另一方面，传感器网络的生命周期应该足够长，以满足应用需求。因此，在设计覆盖确定点的无线传感器网络解决方案时，必须考虑延长网络生命周期。确定传感器节点的位置以使目标被覆盖并使网络寿命最大化的问题称为传感器部署问题。目前，已有各种方法，如启发式算法和近似算法，来解决无线传感器网络中的传感器部署问题。本文采用两种改进的粒子群算法（PSO）来解决传感器部署问题。第一种算法是合作粒子群算法，第二种算法是基于模糊逻辑的改进型合作粒子群算法。仿真结果表明，与其他同类算法相比，本文提出的算法解决了网络生存期较长的目标覆盖问题。

### 1.传感器部署方法引言

无线传感器网络是由分布在特定区域的大量传感器节点组成的。无线传感器网络的主要任务是处理从传感器收集的数据，以监测区域内的事件。在无线传感器网络中，传感器节点从该区域收集数据并将其发送到基站（也称为接收器）。无线传感器网络对许多军事和民用应用（如战场监视、安全和灾害管理）的效率有着重要的影响。然而，传感器节点有其自身的局限性，如能量、通信范围、处理和存储限制。无线传感器网络的网络生存期是指所需区域或点不再被覆盖的持续时间。**网络生存期（network lifetime）**是决定无线传感器网络效率的一个非常重要的标准。影响网络生命周期缩短的主要因素之一是网络中传感器节点的高功耗或能量消耗不均衡。这是因为每个传感器节点的电源都是一个电池，由于被覆盖区域的状况，可能无法再充电或更换。因此，需要对整个网络的能量消耗进行控制和均衡，以提高网络的生存期。因此，这些网络中使用的算法必须考虑传感器节点的能量消耗。

无线传感器网络在覆盖一个区域时，对该区域的监测需要一定的可靠性。因此，以传感器节点在网络中的位置为基本输入的无线传感器网络中的覆盖问题已经被定义。一般来说，覆盖问题可以分为两类：区域覆盖问题和目标覆盖问题。区域覆盖问题集中在对整个期望空间的监控上，而目标覆盖问题则集中在对区域内某些特定点的监控上。目标覆盖问题可以分为以下几类：

1. 简单覆盖：在这个问题中，每个目标都必须由至少一个传感器监控。
2. K-覆盖：在这个问题中，每个目标至少应该被$k$个传感器节点监控。其中$k$是一个预先确定的常数整数。
3. Q-覆盖：在这个问题中，目标$T=\{T_1, T_2, \cdots , T_n\}$的向量必须由$Q=\{q_1, q_2, \cdots, q_n\}$个传感器节点的数量来监控，这样目标$T_j$至少由$q_j$个传感器节点来监控，其中$n$是目标的数量，且$1 \le j \le n$。

在 Chaudhary 和 Pujari 等人的研究中，他们展示了可以根据传感器节点的位置，对 WSN 的网络生存期的上界（upper bound)进行数学计算。该界可用于计算节点的位置，使网络获得两个性质：满足覆盖条件和最大化网络生存期。确定传感器节点的位置以使网络具有上述特性的问题称为传感器部署问题，这是一个*NP-hard*问题。

到目前为止，已经有很多方法被提出来解决这个问题，比如粒子群优化算法(PSO)，人工蜂群(ABC)和遗传算法(GA)，这些方法将在下一节中解释。 然而，这些方法都是近似方法，每一种方法都能得到问题的近似解。 另一方面，由于这个问题是一个 NP-hard 问题，因此没有一个精确的多项式时间算法来解决这个问题。 因此，总是希望找到一个更好的近似值来解决这个问题。

在本文中，我们使用两个改进的粒子群算法来解决传感器部署问题。 第一个版本是协作粒子群算法(den Bergh and Engelbrecht 2004) ，它是粒子群算法的改进版本。
第二种是基于模糊逻辑的协同粒子群算法(Neshat 2013) ，其中每个粒子速度方程中的加速系数采用模糊逻辑控制。 在(den Bergh and Engelbrecht 2004; Neshat 2013)中，已经证明这些改进版本的粒子群优化算法比传统的粒子群优化算法产生更好的结果。这是因为这些改进的版本试图控制探索和开发之间的平衡，其中环境本身会随着时间的推移而动态变化。粒子群优化算法不能动态地适应变化的环境，在迭代的第一阶段很快收敛到最优解。 此外，原始粒子群优化算法的另一个主要缺点是，它可能会陷入一个次优解区域，并且对于高维问题而言，这个问题通常会变得更加困难。 利用这两种改进的粒子群优化算法，较好地解决了无线传感器网络中的传感器部署问题。 仿真结果表明，与其他同类算法相比，改进的粒子群算法能够更好地解决传感器部署问题，提高网络生命周期。 本文的主要特点和贡献突出如下：

- 利用改进的粒子群优化算法(PSO) ，通过协作粒子群优化算法，解决了传感器部署问题的多种版本、简单覆盖、 K-覆盖和 Q-覆盖问题。
- 针对传感器部署问题，提出了粒子群优化算法中粒子速度方程中加速度系数的模糊控制方法。
- 利用改进的协同粒子群优化算法，采用模糊逻辑系统控制加速度系数，解决了多种传感器配置问题
- 给出了算法的仿真结果，仿真结果表明，与其他类似算法相比，提出的算法延长了网络生命周期。

论文的其余部分安排如下: 下一节将描述以前有关无线传感器网络覆盖问题的工作。 第三部分给出了网络生命周期上界的数学计算和传感器部署问题。 第四部分描述了用协同粒子群算法和模糊逻辑算法相结合来解决传感器部署问题。 这些算法在不同场景下的仿真结果在第 5 节中进行了描述。 最后，对第六部分的工作进行了总结，并展望了未来的研究方向。

### 2.传感器部署方法相关工作

到目前为止，针对无线传感器网络中的传感器部署问题，已经提出了各种解决方案。 这个部分介绍了其中一些与我们的工作最相关的方法。

Elhoseny 等人(2017)利用遗传算法(GA)解决了无线传感器网络中的 k-覆盖问题。他们关注的是网络中的能源消耗。该算法考虑了目标位置、预期能量消耗和各传感器的覆盖范围等不同因素。然而，在遗传算法的适应度函数中没有考虑网络生命周期，这意味着该算法没有考虑延长网络生命周期。

Lu 等人(2014)解决了无线传感器网络中的简单覆盖问题。 他们的主要目标是延长网络生命周期。
为了达到这个目的，他们使用一个多项式时间逼近方案来调度传感器节点的清醒和睡眠状态。 提出的近似演算法协议提高了网络的生命周期。 然而，他们还没有解决传感器部署问题。

Njoya 等人(2017)基于一种定义可移动、合并、重组和爆炸虚拟节点的新方法，解决了无线传感器网络中的简单覆盖问题。 这种方法被称为虚拟传感器，在保持完全覆盖的同时减少了实际传感器的数量。 但是，它的目标并不是最大化网络生存期。

Ozdag (2018)基于类电磁(EM)算法解决了无线传感器网络中的 q 覆盖问题。Em 算法是一种基于粒子间电磁吸引和排斥的新型进化算法。 通过仿真，将该算法与该算法进行了比较。该算法是在 2018 年提出的，并与 2016 年提出的粒子群优化算法进行了比较。 仿真结果表明，在传感器节点少于 250 个、目标少于 25 个的情景下，EM 算法的性能优于本文提出的 PSO 算法(özda 和 karc 2016)。

Cheng 和 Wang (2017)定义了一种新的目标覆盖问题，称为无线传感器网络中的目标障碍覆盖问题。 在这个问题中，对于每个目标，定义一个目标障碍物，它是在目标周围形成的连续的圆形障碍物。 他们用最少的传感器节点来构造目标屏障，解决了这个问题。 Yu 等人(2017)通过使用集中式和分布式协议解决了无线传感器网络中的 k 覆盖问题。 这些协议考虑了剩余能量和较低的传感器空间密度，解决了这个问题。 然而，(Cheng and Wang 2017)和(Yu et al. 2017)没有考虑传感器部署问题，这意味着他们不确定传感器节点的位置。

Binh 等人(2018)已经解决了无线传感器网络的区域覆盖问题。本文采用了一种改进的布谷鸟搜索算法和混沌花授粉算法来解决这一问题。 这些算法改进了局部搜索算法，使算法得到了改进，问题得到了较好的解决。 仿真结果表明，这两种算法具有较好的区域覆盖率。 但是，它们并不解决传感器部署问题。

Mini 等人(2013 年)已经研究了简单覆盖，k 覆盖和 q 覆盖问题在无线传感器网络。他们通过使用一个贪婪的启发式的人工蜜蜂群体(ABC)和粒子群优化群体(PSO)算法来解决这些问题。 这些算法的主要目标是最大化网络生命周期。 在这些算法中，粒子群算法为这些问题提供了更好的解决方案。

Mansour 和 Jarray (2015)通过使用一个近似演算法数据库解决了无线传感器网络的区域覆盖问题。这个算法是基于线性规划。 首先，他们将问题转化为一个整数 / 线性规划问题，然后通过迭代和松弛技术得到问题的近似答案。 然而，解决线性规划问题最好也是最常用的方法是椭球算法。椭球算法虽然运行在多项式时间内，但实际上速度很慢。 尽管如此，它仍然是开发求解线性规划的多项式时间算法的一个非常重要的理论工具。 另一方面，将无线传感器网络的覆盖问题建模为线性规划问题会导致线性规划问题的实例规模非常大，因为在某些无线传感器网络的应用中，传感器节点的数量过大。 因此，在无线传感器网络中，解决一个基于覆盖问题的线性规划问题是非常昂贵的。

Gupta 等人(2015)研究了连接$m$个无线传感器网络的 k-覆盖问题。 针对具有 k-覆盖和 连接$m$个无线传感器网络节点数量最少的优化配置问题，提出了一种解决方案。 该方法适用于 $k$ 和 $m$ 的不同取值。但该方法没有考虑网络生命周期。 他们的目标是最小化传感器节点的数量。

同时，也有其他的研究工作通过粒子群算法来解决不同版本的无线传感器网络覆盖问题。在（Ab Aziz 等人。2009 年）的研究中，一个版本的覆盖问题已经被 PSO 解决了。文章采用粒子群优化算法，根据基于 Voronoi 图的适应度函数，寻找传感器节点的最优位置。（Ab-Aziz 等人。2009 年）和本文是版本的覆盖问题。在（Ab-Aziz 等人。2009 年），目标是如何在区域内定位传感器节点，以使覆盖百分比最大化，覆盖空洞最小化。然而，在本文的覆盖问题中，目标是如何在区域内定位传感器节点，从而使网络寿命最大化。

在(Wang et al. 2007a，b)中，移动无线传感器网络的覆盖问题已经由粒子群优化和模拟退火解决。 该研究的目标是寻找移动传感器节点的最佳部署，以满足感知覆盖要求，最大限度地降低通信能量消耗。 和本文的主要区别在于(Wang et al. 2007a，b)假设在无线传感器网络中，传感器节点是移动的。 然而，在本文中，我们认为传感器节点是静止的。 因此，问题和解决方案是不同的。

在(Wang 等人 2018)中，针对无线传感器网络中的能量效率和覆盖率问题，提出了一种基于粒子群优化的覆盖控制算法。 从一个角度来看，覆盖问题可以分为两类: 随机部署和计划部署。 在(王等。2018) ，随机部署的考虑，这意味着传感器节点部署在该地区随机。 然后利用粒子群优化算法对传感器节点的感知半径进行调整，使传感器节点在密集区域缩小感知半径，在稀疏区域扩大感知半径。 然而，本文提出的算法主要是针对计划部署类的覆盖问题。 在(Wang 等人 2007a，b)和(Ismail 和 Manaf 2010)中，PSO 已经解决了无线传感器网络的覆盖问题。 在这两项工作中，我们认为传感器节点在部署后可以移动。 因此，这两种工作中提出的算法都不适用于只有静态传感器节点的无线传感器网络。 然而，本文提出的算法适用于只有静态传感器节点的无线传感器网络。

在(ZainEldin 等人 2020)中，提出了一种新的算法，以最小的传感器节点数最大化覆盖率。 该算法采用遗传算法进行求解。 定义了两个目标函数。 第一个目标是最大化区域覆盖率，第二个目标是最小化有助于最小化传感器节点之间重叠区域的传感器节点数量。仿真结果表明，该算法的性能优于其他类似算法。

在(Kanwar 和 Kumar 2020) ，传感器部署的问题已经解决后，网络已经开始运作。 在无线传感器网络中，由于一些节点的死亡，网络被分割成若干部分。 因此，需要一种部署算法在适当的位置部署新的传感器节点，以连接网络的不同部分。 本文提出了解决这一问题的办法。 但是，这项工作没有考虑到无线传感器网络中部署问题的一般形式。 在(穆萨等人。2019 年) ，传感器部署问题已经解决的方式，平衡能源消耗的网络。实际上，它分配了传感器节点的能量消耗。 然而，与其他类似算法相比，这种方法并没有最大化无线传感器网络的生存期。

表 1 对上述算法进行了总结和比较。 然而，以最大化网络生命周期为目标的各种目标覆盖问题(我们称之为传感器部署问题)都是 np 难问题。 因此，没有一个精确的多项式时间算法来解决这些问题。 上述算法都是近似算法，每一种算法都能得到问题的近似解。

人们总是希望找到一个更好的近似值来解决这些问题。 为了达到这个目标，我们使用两个改进的粒子群算法来解决这些问题。 第一个版本，在第 4.2 节中给出，被称为协作 PSO 算法，可以在(den Bergh and Engelbrecht 2004; Goh et al. 2010; Li and Yao 2011)中找到。 第二个版本，在第 4.4 节中给出，使用模糊逻辑来改进协作 PSO 算法，它可以在(Liu 等人。2010; Neshat 2013; Niu et al. 2008; Valdez et al. 2011). 在(den Bergh 和 Engelbrecht 2004)中，首次引入了协作粒子群算法。 在(Goh 等人，2010 年) ，一个多目标版本的协作粒子群算法被提出。 在(李和姚 2011)中，改进了协作粒子群算法，以更好地解决大规模优化问题(多达 2000 个实值变量)。 在(Neshat 2013)中，介绍了一个改进的版本使用模糊逻辑。在(Liu 等人，2010 年) ，一个改进的粒子群算法，使用模糊逻辑，是用来解决调度工作问题。 在(牛等。2008)中，一个新的模糊建模策略被用来提供一个更好的改进协作粒子群算法使用模糊逻辑。 在(瓦尔迪兹等人 2011 年) ，粒子群算法是结合遗传算法使用模糊逻辑提供了一种进化方法。

### 3.网络生存期的上界和问题定义

#### 3.1 网络生存期的上界

对于无线传感器网络，可以根据网络中传感器节点的位置和能量，以数学方式确定网络生存期的上限(Chaudhary 和 Pujari，2009 年; Gu 等人，2007 年)。 我们可以利用这种方法来确定传感器的位置，从而使网络生命周期最大化。 考虑一个包含传感器节点需要监视的目标点的区域。 上限计算如下(Chaudhary 和 Pujari，2009 年; Gu 等人，2007 年) :

假设 $m$ 个传感器节点$\{S_1,S_2,\cdots, S_m\}$被部署到覆盖 区域$R$的 $n$ 个目标 $\{T_1, T_2, \cdots, T_n\}$。每个传感器节点有初始能量$E_0$和感应半径 $s_r$。 传感器节点 $S_i, 1 \le j \le n$，如果 $S_i$ 和 $T_j$ 之间的距离小于 $s_r$，则称已覆盖目标 $T_j, 1 \le j \le n$。覆盖矩阵定义为:

![NLCim4.png](https://s1.ax1x.com/2020/07/02/NLCim4.png)

其中 $i = 1,2, \cdots, m$ 和 $j = 1,2, \cdots, n$。 我们定义了${b}'_i = \frac{b_i}{e_i}$ 来表示电池的寿命，其中 $b_i$ 是电池的初始功率，$e_i$ 是节点 $S_i$ 的能量消耗率。 网络生存期的上限计算如下:

![NLFBHe.png](https://s1.ax1x.com/2020/07/02/NLFBHe.png)

其中 $q_j = k, j = 1,2, \cdots, n$表示 k-覆盖。 在(Chaudhary 和 Pujari，2009; Gu 等人，2007)中，已经证明了形如最大化$U$的覆盖问题是一个*np-hard*问题。 本文采用两种改进的粒子群优化算法来解决这一问题。 在这些算法中，目标(适应度)函数是$U$。

#### 3.2 网络生存期问题定义

本节给出了本文所解决的各种传感器部署问题的精确定义。 考虑位于 $u \times v$ 区域的 $n$ 个目标，包括 $m$ 个传感器节点。 该算法的目标是寻找传感器节点在该区域内的位置，以满足所需的覆盖条件，使网络生命周期最大化。根据所需的覆盖条件，传感器部署问题的三个不同版本定义如下:

1. 简单覆盖：部署传感器节点，使每个目标至少由一个传感器节点监视，网络生命周期最大。 事实上，目的是最大化 $U$ 在公式(2)中的值，使每个目标受到至少一个传感器的监视。
2. K-覆盖: 给定一组 $n$ 个目标 $t=\{T_1,T_2, \cdots, T_n \}$ 位于 $u \times v$ 区域，包括 $m$ 个传感器节点 $S=\{S_1,S_2, \cdots , S_m\}$，目的是将传感器节点放置在该区域，使每个目标至少受到 k 个传感器节点的监视，并且最大化公式(2)中的$U$。
3. Q-覆盖: 给定一组 $n$ 个目标 $t = \{T_1,T_2, \cdots,T_n\}$ 位于一个$u \times v$ 区域，其中包括 $m$ 个传感器节点 $S=\{S_1,S_2, \cdots , S_m\}$ 和一个向量 $q = \{q_1, q_2, \cdots, q_n\}$，目的是布置节点，使每个目标 $T_j, 1 \le j \le n$，至少被 $q_j$ 传感器节点覆盖，并在公式(2)中使 $U$最大化。

### 4.本文的提出的粒子群优化方法

在这一部分中，我们描述了所提出的解决无线传感器网络中传感器部署问题的算法。 在本文中，我们认为传感器节点的位置可以在它们被部署之前被确定。 本文提出的算法的任务是在传感器节点部署前确定其在区域内的位置。 首先，对粒子群优化算法进行了概述。

#### 4.1 粒子群优化算法概述

粒子群优化（PSO）是一个庞大的群体智能方法(Mavrovouniotis et al)用于解决优化问题。PSO 首先由 Eberhart 和 Kennedy（1995）提出。这种方法的灵感来源于成群迁徙的动物的自然生活。由于群体中的每个成员都会根据群体来调整自己的位置和速度，从而减少了个体在寻找食物、住所等方面的行为影响。
粒子群优化算法由一群粒子组成。每个粒子都是问题的完整解决方案。每一个粒子群都有自己的速度，这种速度会随着它在搜索空间中的移动而变化。此外，每个粒子都有一个内存，它在其中保存了它曾经处于的最佳位置。每个粒子都朝着自己的最佳位置以及整个群的最佳位置移动。为此，每个粒子的速度向量和位置向量都会根据它们所处的最佳位置和整个群中的最佳位置进行更新。

#### 4.2 合作粒子群算法(CPSO)

#### 4.3 利用 CPSO 解决传感器部署问题

提出了一种基于 cpso 的传感器部署算法，该算法包括粒子编码方案、粒子初始化、适应度函数的确定、速度和位置更新阶段以及终止准则。

(1) 粒子编码方式

利用标准粒子群算法解决传感器部署问题，假设每个粒子都是问题的可行解。 假设我们有一个拥有 $m$ 个节点的网络和一个规模为 $u \times v$ 的二维传感器部署区域。 要部署每个传感器节点，需要两个维度 $x$ 和 $y$。 因此，问题的每个可行解都是一个粒子，它等于 $m$ 对 $\{(x_1,y_1),(x_2,y_2), \cdots ,(x_m,y_m)\}$，其中$0 \le x_i \le u$，$0 \le y_i \le v$对于每个 $i \in \{1,2, \cdots ,m \}$，$(x_i,y_i)$是第$i$个传感器节点的位置。每个群体都是一个粒子的集合; 这意味着每个群体都是问题的可行解决方案的集合。 因此，在使用标准粒子群算法解决传感器部署问题时，一个大小为 $l$ 的群确实是该区域传感器节点不同部署的集合。
:::tip 思考
这里的$l$代表的是粒子群的粒子个数，按照上述表示方式，对于$m$个节点的网络，粒子群的单个粒子的维度应该是$2m$，一个粒子就能代表一种$m$个传感器的分布。
:::

为了解决使用 CPSO 的传感器部署问题，我们假设我们有$m$个一维群( ==实际上是二维群，因为是一对$(x_i,y_i)$== )，其中每个群是**一个**传感器节点在该地区的不同部署的集合。 通过这种方式，传感器部署问题不再依赖维度( ==因为维度靠群数量进行替换了，一个群代表一个传感器，维度都是一维，准确的说是二维== ); 因此，每个群体被认为是一维的，因为每两个传感器的部署彼此独立（ ==严格说来相互之间并不独立，因为传感器区域尽量不要重合，尤其是简单部署问题。当然，每个传感器都可以随便放是真的== ）。

因此，我们有$m$个大小为$l$的群。该算法的主要目的是在区域内寻找传感器节点的部署使得网络生命周期最长。该算法可以找到问题的最优解或近似最优解。 如果将两个不同的传感器节点部署在同一位置，从而减少了网络的生存时间，该算法将改变节点的位置。每个群 i (1≤ i ≤ m)由 l 对组成，表示为 li = x1，y1，x2，y2，... ，xl，yl，其中每个对 xj，yj 是区域内 i-th 节点的位置，对于每个 j ∈{1,2，... ，l } ，0≤ xj ≤ u 和 0≤ yj ≤ v。 在本算法中，上下文向量由 m 对组成: x1，y1，x2，y2，... ，xm，ym，其中 xi，yi 是第 i 传感器节点的位置，对每个 i ∈{1,2，... ，m } ，0≤ xi ≤ u 和 0≤ yi ≤ v。
:::warning 理解
相当于进行了维度对调，普通的粒子群算法是$l$个$2m$维度的粒子，CPSO 则用多个群（$m$个粒子群），每个粒子群由$l$个粒子组成，每个粒子都是一维（实际是二维）。
:::

传感器节点的部署必须满足传感器部署问题的要求条件。 每个群体的任务是部署一个传感器节点，以满足部署问题的条件。 用这种方法，我们不是解 $m$ 维问题，而是解 $m$ 个一维问题。 在 CPSO 中，上下文向量将在每次迭代中用 _Gbest_( ==全局最优，就是 CPSO 中的上下文环境向量，由$m$个粒子群中最优的那个粒子位置合并得来== ) 填充。 在算法的每一次迭代中，_Gbest_ 是传感器部署问题的一个可行解。 当一个 _Gbest_ 元素被一个粒子代替时，我们检查这个解决方案是否提供了传感器部署问题所需的条件。 如果不是，那个 _Gbest_ 元素将被另一个适应值大于该群中其他粒子的粒子所取代（ ==为什么是被适应度更大的取代，我们不就是为了找最大化适应度函数$U$么？那不应该一开始就用最大的适应度粒子:dog:，另外 CPSO 中是一个维度一个维度进行计算，万一群里面的$l$个粒子都没有符合条件，肿么办？== ）。 实际上，我们的算法始终保持 _Gbest_ 为问题的一个可行解，这意味着 _Gbest_ 满足传感器部署问题的要求条件。

(2)粒子的初始化

每个群体中的每个粒子都可以被识别为一对$(x,y)$。为了初始化粒子，对每个粒子生成两个随机数 $x$ 和 $y$，使得 $0 \le x \le u$ 和 $0 \le y \le v$。

(3)适应度函数
这里的主要目标是确定传感器节点的位置，以便满足所需的条件并使网络寿命最大化。因此，适应度函数是公式(2)中的 $U$，它实际上就是网络生存期。

(4)速度和位置更新
每个粒子的速度和位置在每次迭代中都使用公式(3)和(4)进行更新。然而，这些方程中加减运算的代数步骤可能会导致粒子的新位置超出范围（不在$u\times v$范围内）。因此，所提出的算法处理粒子的位置，要能使它们落在期望的范围内。以下三个规则处理粒子$(x,y)$的这些场景：

1. 如果 x 或 y 是负数，用一个新的随机数替换它。
2. 如果$x>u$，那么$x=u$。
3. 如果$y>v$，那么$y=v$。

在生成新的位置后，第$i$个群（$1\le i\le m$）中的每个粒子被上下文向量中的第 i 个元素替换。然后，利用适应度函数计算上下文向量。现在，只要它的当前适应值比它的 _Pbest_ 适应值好，那么每个粒子的 _Pbest_ 就会被替换掉。然后，根据粒子适应度函数的值对 _Gbest_ 进行更新。
:::tip 理解
也就是说粒子的 _Pbest_ 的是不考虑覆盖条件，只考虑适应度值函数的。但是 _Gbest_ 必须考虑，所以下面着重开始说 _Gbest_ 的情况。
:::

更新 _Gbest_ 的过程必须考虑所需的覆盖条件。事实上，它必须更新 _Gbest_，使之成为解决问题的可行方案。换句话说，必须更新 _Gbest_，使其满足所需的覆盖条件。为了实现这一目标，在将一个粒子放入 _Gbest_ 的每个步骤中，都会检查所需的覆盖条件；如果不满足这些条件，则将另一个满足所需覆盖条件的粒子放入 _Gbest_。然后，上下文向量将填充 _Gbest_。
::: warning 理解
说白了，就是 _Gbest_ 必须满足覆盖条件（比如必须每个目标都要被覆盖到，或者第$k$个目标被$q_k$个传感器覆盖呀等等），如果放入的粒子不满足条件，则换一个（那这样每个粒子群自身的*Gbest*不就没有意义了么？
:::

(5) 终止条件

迭代更新速度和位置，直到满足终止条件。在我们的算法中，终止条件是预先定义好的迭代次数。Gbest 表示节点的最终部署情况。CPSO 算法的伪码如下所示。

```
输入：l, m, u, v
对于m个粒子群，初始化中每个群中l个粒子
没有达到最大迭代次数则进行循环{
  对于每个群进行循环{
    对于每个群中的粒子进行循环{
      更新上下文环境向量
      计算上下文环境向量的网络生存期，并把它放到UCurrent中
      如果UCurrent>Pbest{
        将当前值设置为该粒子的新Pbest
      }
    }
  }
  在所有粒子中选择适应度值最佳的粒子作为Gbest，使其满足传感器部署问题所需的条件
  用Gbest填充上下文向量
  对于每个粒子进行循环{
    根据速度更新方程（3）计算粒子速度
    根据位置更新方程（4）更新粒子位置
  }
}
输出：Gbest
```

:::danger 疑问
每个群自己的 Gbest 提供出来作为环境向量，那万一各个群拼起来的环境向量不符合约束条件呢？（比如 K 约束），那么这时候应该用哪种策略进行修正？另外初始的 Gbest 要怎么获得，因为必须要满足约束条件。
:::

**实例 1**：考虑 $K=3$ 的 $K$ 覆盖问题，共有 6 个传感器节点，2 个目标的无线传感器网络，$m=6$，$n=2$，CPSO 中每个群有 20 个粒子，即 $l=20$。在这个例子中，目标是在区域中部署传感器节点，使得每个目标被至少 3 个传感器节点覆盖，并且实现最大的网络生存期。用粒子群算法解决这个问题的模型是将每个粒子作为传感器节点的一个部署。因此每个粒子都可以用$p_i$表示，$p_i=\{(x_1,y_1),(x_2,y_2),\cdots,(x_6,y_6)\}$，其中$1\le i \le 20$，因此，群集合可以用$L=\{p_1,p_2,\cdots, p_{20}\}$表示。

为了用 CPSO 来解决这个问题，我们假设我们有 6 个一维群，其中每个群都是该区域传感器节点不同部署的集合。因此，我们有 6 个群$\delta_1,delta_2,\cdots,delta_6$，并且 $\delta_j$是该区域传感器节点 j 的不同部署的集合。现在在这个问题示例上实现图 1 所示算法的步骤 3 到 20。

在下一个例子中，给出了算法提供的最终部署。

#### 4.4 用模糊逻辑改进 CPSO（CPSO_ufuzzy）

我们现在提出了一种改进的合作粒子群算法（CPSO_fuzzy）。公式(3)中用$c_1$和$c_2$表示的恒定加速度系数将每个粒子引导到*Pbest*和*Gbest*位置。这意味着随着迭代次数的增加，这些系数将导致粒子向*Pbest*和*Gbest*位置移动。这些系数很大会使粒子突然向目标区域移动（尽管最佳解不一定在该区域），而较低的值允许粒子远离目标区域漫游。最近，对粒子群算法（试错法）的检验表明，如果加速度系数等于 2，则会获得更好的结果。然而，这并不总是正确的（Ratnaweera 等人。2004 年）。有时在问题的搜索空间中，全局搜索优于局部搜索，反之亦然。在迭代过程中，如果加速度系数以智能的方式变化并适应当前条件，则可以获得更好的结果。

## CPSO 算法

> 粒子群优化(PSO)是一种随机的，基于种群的优化技术，可以应用于广泛的问题，包括神经网络的训练。 本文提出了一种改进的传统粒子群优化算法，称为合作粒子群优化器，或 CPSO，利用合作行为显着提高了原算法的性能。 这是通过使用多个群优化解决方案向量的不同组成部分合作实现的。 新的粒子群算法在几个基准优化问题上的应用表明，与传统粒子群算法相比，性能有了明显的改善。

### 1. 原始 PSO 算法和名词解释

![NLyeeI.png](https://s1.ax1x.com/2020/07/02/NLyeeI.png)

:::tip 名词解释
标准粒子群算法伪代码中，对于一个粒子群中的第$i$个粒子，$P:P.x_i, P.v_i, P.y_i$分别代表粒子的位置，速度和局部最优位置，$P.\hat{y}$代表全局最优位置，$f$代表适应度函数。
:::

### 2.CPSO-SK 算法

原始的粒子群算法使用 $n$ 维向量的种群(一个粒子是$n$维向量，代表一个解)。事实上，可以把$n$维向量分成 $n$ 个一维向量，对每个一维向量使用粒子群进行优化，这时每个粒子群就代表原问题的一个维度。 每个粒子群都试图优化最优解的一个组成部分（维度），本质上是一维优化问题。 这种分解类似于松弛法中使用的分解。

这种这种方法的一个复杂之处在于，要最小化的函数（目标函数）$f$ 需要一个 $n$ 维向量作为输入。 如果每个群体只代表搜索空间的一个维度，那么显然不可能直接计算每个粒子群的个体适应度（因为只有一个维度，所以没法用适应度函数算）。这时我们需要提供一个合适的上下文环境向量（**context vector**），在这个上下文环境中就可以评估每个粒子群中的个体。构造这样一个上下文向量最简单的方案是从每一个群中取出全局最佳粒子，并将它们连接起来形成这样一个 n 维向量。 为了计算粒子群$j$中所有粒子的适应度，上下文环境向量中的其他$n-1$个分量保持不变(其值设置为来自其他$n-1$粒子群的全局最优粒子)，而上下文环境向量的 $j$ 分量依次由来自 第$j$个粒子群的每个粒子代替。

![NLsqWF.png](https://s1.ax1x.com/2020/07/02/NLsqWF.png)

其中$b(j,z)$表示在全局最优组成的变量中，第$j$维变成$z$

图 2 展示了 CPSO-S 算法，它首先由 vandenbergh 和 Engelbrecht 在文献 9 中引入，这是一种将搜索空间精确划分为子空间的粒子群优化算法。扩展图 1 中介绍的约定，**$P_j.x_i$现在指的是粒子群$j$中第$i$个粒子的位置**，当有需要则可以将其替换为上下文环境向量的第$j$部分分量。对于$n$个粒子群，每个群都有一个全局最佳粒子$P_j.\hat{y}$。函数$b(j,z)$返回一个$n$维向量，该向量由所有群中的全局最佳向量串联而成，但第$j$分量被替换为$z$，其中$z$表示粒子群$P_j$中任何粒子的位置。

该算法的优点是在向量中的每个分量更新后，对误差函数$f$进行求值，从而得到更细粒度的信用分配。$b(1, P_i.\hat{y})$将表示当前“最佳”上下文向量。请注意，$f(b(1, P_i.\hat{y}))$是一个严格不递增的函数，因为它是由每个群的全局最佳粒子$P_j.\hat{y}$组成的，只有当它们的适应度提高时，这些粒子才会更新。

组中的每个粒子群只包含关于解向量的特定分量的信息；解向量的其余部分由其他$n-1$个粒子群提供。这促进了不同群体之间的合作，因为它们都有助于上下文向量。对合作机制的另一种解释是可能的。每一个粒子群代表一个不同的上下文，在这个上下文中，向量被计算在不同的上下文中，因此上下文向量本身的适应度是在不同的上下文中度量的。与产生最高适应度的粒子相对应的最成功的上下文将被保留以备将来使用。例如，一个 30 维的搜索空间会产生一个包含 30 个一维群的 CPSO-S 算法。在算法的一次迭代过程中，形成了不同的组合，而原始粒子群算法只产生了 30 个变量。CPSO-S 方法的优点是一次只修改一个组件，产生所需的细粒度搜索，有效地防止了“两步前进，一步后退”的情况。在 CPSO-S 算法中，由于使用来自不同群的不同成员形成的许多组合，解的多样性也显著增加。

请注意，如果向量中的某些成分是相关的，它们应该被分组到同一个粒子群中（通过使用任意配置的划分机制），因为不同粒子群所做的独立更改将对相关变量产生不利影响。这导致一些群具有一维向量，而另一些群具有$c$维向量，这在上述框架中很容易被允许。不幸的是，并不总是预先知道各向量之间的关系。一个简单的近似方法是一次盲目地取变量，希望一些相关变量最终会出现在同一个群中。图 3 展示了 CPSO-$S_k$算法，其中一个向量被分成了几个部分。注意，图 2 中所示的 CPSO-$S_k$算法实际上是 CPSO-S 算法的一个特例。分成各部分的数量$K$也被称为分割因子。
